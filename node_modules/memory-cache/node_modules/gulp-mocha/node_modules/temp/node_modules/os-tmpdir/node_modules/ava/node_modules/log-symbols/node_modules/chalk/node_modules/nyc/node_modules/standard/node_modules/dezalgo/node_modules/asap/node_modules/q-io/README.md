
[![Build Status](https://secure.travis-ci.org/kriskowal/q-io.png)](http://travis-ci.org/kriskowal/q-io)

# Q-IO

Interfaces for IO that make use of promises.

Q-IO now subsumes all of [Q-HTTP][] and [Q-FS][].

[Q-HTTP]: https://github.com/kriskowal/q-http
[Q-FS]: https://github.com/kriskowal/q-fs

The Q-IO package does not export a main module.  You must reach in
directly for `q-io/fs`, `q-io/http`, and `q-io/http-apps`.

## Filesystem

```javascript
var FS = require("q-io/fs");
```

File system API for Q promises with method signatures patterned after
[CommonJS/Fileystem/A](http://wiki.commonjs.org/wiki/Filesystem/A) but
returning promises and promise streams.

### open(path, options)

Open returns a promise for either a buffer or string Reader or a Writer
depending on the flags.

The options can be omitted, abbreviated to a `flags` string, or expanded
to an `options` object.

-   ``flags``: ``r``, ``w``, ``a``, ``b``, default of `r`, not bytewise
-   ``charset``: default of ``utf-8``
-   ``bufferSize``: in bytes
-   ``mode``: UNIX permissions
-   ``begin`` first byte to read (defaults to zero)
-   ``end`` one past the last byte to read.  ``end - begin == length``

### read(path, options)

`read` is a shortcut for opening a file and reading the entire contents
into memory.  It returns a promise for the whole file contents.  By
default, `read` provides a string decoded from UTF-8.  With the bytewise
mode flag, provides a `Buffer`.

The options argument is identical to that of `open`.  

```javascript
return FS.read(__filename, "b")
.then(function (content) {
    // ...
})
```

```javascript
return FS.read(__filename, {
    flags: "b"
})
```

### write(path, content, options)

`write` is a shortcut for opening a file and writing its entire content
from a single string or buffer.

The options are identical to that of `open`, but the "w" flag is
implied, and the "b" flag is implied if the content is a buffer.

```javascript
return FS.write("hello.txt", "Hello, World!\n")
.then(function () {
    return FS.read("hello.txt")
})
.then(function (hello) {
    expect(hello).toBe("Hello, World!\n")
})
```

### append(path, content, options)

`append` is a shorthand for opening a file for writing from the end of
the existing content from a single string or buffer.

The options are identical to that of `open`, but the "w+" flags are
implied, and the "b" flag is implied if the content is a buffer.

### copy(source, target)

Copies a single file from one path to another.  The target must be the
full path, including the file name.  Unlike at the shell, the file name
is not inferred from the source path if the target turns out to be a
directory.

Returns a promise for the completion of the operation.

### copyTree(source, target)

Copies a file or tree of files from one path to another.  Symbolic links
are copied but not followed.

Returns a promise for the completion of the operation.

### list(path)

Returns a promise for a list of file names in a directory.  The file
names are relative to the given path.

### listTree(path, guard(path, stat))

Returns a promise for a list of files in a directory and all the
directories it contains.  Does not follow symbolic links.

The second argument is an optional guard function that determines what
files to include and whether to traverse into another directory.  It
receives the path of the file, relative to the starting path, and also
the stats object for that file.  The guard must return a value like:

-   `true` indicates that the entry should be included
-   `false` indicates that the file should be excluded, but should still
    be traversed if it is a directory.
-   `null` indiciates that a directory should not be traversed.

### listDirectoryTree(path)

Returns a promise for a deep list of directories.

### makeDirectory(path, mode)

Makes a directory at a given path.  Fails if the parent directory does
not exist.  Returns a promise for the completion of the operation.

The mode is an optional Unix mode as an integer or string of octal
digits.

### makeTree(path, mode)

Finishes a path of directories.  For any branch of the path that does
not exist, creates a directory.  Fails if any branch of the path already
exists but is not a directory.

Makes any directories with the given Unix mode.

### remove(path)

Removes a file at the given path.  Fails if a directory exists at the
given path or if no file exists at the path.

### removeTree(path)

Removes a file or directory at a given path, recursively removing any
contained files and directories, without following symbolic links.

### rename(source, target)

Moves a file or directory from one path to another using the underlying
`rename(2)` implementation, thus it cannot move a file across devices.

### move(source, target)

Moves a file or directory from one path to another.  If the source and
target are on different devices, falls back to copying and removing,
using `copyTree(source, target)` and, if completely successful,
`removeTree(source)`.

### link(source, taget)

Creates a hard link from the source

### symbolicCopy(source, target, type)

Creates a relative symoblic link from the target to the source with an
effect that resembles copying a file.

The type is important for Windows.  It is "file" by default, but may be
"directory" or "junction".

### symbolicLink(target, link, type)

Creates a symbolic link at the target path.  The link may be absolute or
relative.  The type *must* be "file", "directory", or "junction" and is
mandatory to encourage Windows portability.

### chown(path, uid, gid)

Changes the owner for a path using Unix user-id and group-id numbers.

### chmod(path, mode)

Changes the Unix mode for a path.  Returns a promise.

### stat(path)

Follows all symoblic links along a path and returns a promise for the
metadata about a path as a `Stats` object.  The Stats object implements:

-   `size` the size of the file in bytes
-   `isDirectory()`: returns whether the path refers to a directory with
    entries for other paths.
-   `isFile()`: returns whether the path refers to a file physically
    stored by the file system.
-   `isBlockDevice()`: returns whether the path refers to a Unix device
    driver, in which case there is no actual data in storage but the
    operating system may allow you to communicate with the driver as a
    blocks of memory.
-   `isCharacterDevice()`: returns whether the path refers to a Unix
    device driver, in which case there is no actual data in storage but
    the operating system may allow you to communicate with the driver as
    a stream.
-   `isSymbolicLink()`: returns whether the path refers 