<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>UglifyJS &ndash; a JavaScript parser/compressor/beautifier</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2011-12-09 14:59:08 EET"/>
<meta name="author" content="Mihai Bazon"/>
<meta name="description" content="a JavaScript parser/compressor/beautifier in JavaScript"/>
<meta name="keywords" content="javascript, js, parser, compiler, compressor, mangle, minify, minifier"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="docstyle.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">UglifyJS &ndash; a JavaScript parser/compressor/beautifier</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 UglifyJS &mdash; a JavaScript parser/compressor/beautifier </a>
<ul>
<li><a href="#sec-1-1">1.1 Unsafe transformations </a>
<ul>
<li><a href="#sec-1-1-1">1.1.1 Calls involving the global Array constructor </a></li>
<li><a href="#sec-1-1-2">1.1.2 <code>obj.toString()</code> ==&gt; <code>obj+“”</code> </a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2 Install (NPM) </a></li>
<li><a href="#sec-1-3">1.3 Install latest code from GitHub </a></li>
<li><a href="#sec-1-4">1.4 Usage </a>
<ul>
<li><a href="#sec-1-4-1">1.4.1 API </a></li>
<li><a href="#sec-1-4-2">1.4.2 Beautifier shortcoming &ndash; no more comments </a></li>
<li><a href="#sec-1-4-3">1.4.3 Use as a code pre-processor </a></li>
</ul>
</li>
<li><a href="#sec-1-5">1.5 Compression &ndash; how good is it? </a></li>
<li><a href="#sec-1-6">1.6 Bugs? </a></li>
<li><a href="#sec-1-7">1.7 Links </a></li>
<li><a href="#sec-1-8">1.8 License </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> UglifyJS &mdash; a JavaScript parser/compressor/beautifier </h2>
<div class="outline-text-2" id="text-1">


<p>
This package implements a general-purpose JavaScript
parser/compressor/beautifier toolkit.  It is developed on <a href="http://nodejs.org/">NodeJS</a>, but it
should work on any JavaScript platform supporting the CommonJS module system
(and if your platform of choice doesn't support CommonJS, you can easily
implement it, or discard the <code>exports.*</code> lines from UglifyJS sources).
</p>
<p>
The tokenizer/parser generates an abstract syntax tree from JS code.  You
can then traverse the AST to learn more about the code, or do various
manipulations on it.  This part is implemented in <a href="../lib/parse-js.js">parse-js.js</a> and it's a
port to JavaScript of the excellent <a href="http://marijn.haverbeke.nl/parse-js/">parse-js</a> Common Lisp library from <a href="http://marijn.haverbeke.nl/">Marijn Haverbeke</a>.
</p>
<p>
( See <a href="http://github.com/mishoo/cl-uglify-js">cl-uglify-js</a> if you're looking for the Common Lisp version of
UglifyJS. )
</p>
<p>
The second part of this package, implemented in <a href="../lib/process.js">process.js</a>, inspects and
manipulates the AST generated by the parser to provide the following:
</p>
<ul>
<li>ability to re-generate JavaScript code from the AST.  Optionally
  indented&mdash;you can use this if you want to “beautify” a program that has
  been compressed, so that you can inspect the source.  But you can also run
  our code generator to print out an AST without any whitespace, so you
  achieve compression as well.

</li>
<li>shorten variable names (usually to single characters).  Our mangler will
  analyze the code and generate proper variable names, depending on scope
  and usage, and is smart enough to deal with globals defined elsewhere, or
  with <code>eval()</code> calls or <code>with{}</code> statements.  In short, if <code>eval()</code> or
  <code>with{}</code> are used in some scope, then all variables in that scope and any
  variables in the parent scopes will remain unmangled, and any references
  to such variables remain unmangled as well.

</li>
<li>various small optimizations that may lead to faster code but certainly
  lead to smaller code.  Where possible, we do the following:

<ul>
<li>foo["bar"]  ==&gt;  foo.bar

</li>
<li>remove block brackets <code>{}</code>

</li>
<li>join consecutive var declarations:
    var a = 10; var b = 20; ==&gt; var a=10,b=20;

</li>
<li>resolve simple constant expressions: 1 +2 * 3 ==&gt; 7.  We only do the
    replacement if the result occupies less bytes; for example 1/3 would
    translate to 0.333333333333, so in this case we don't replace it.

</li>
<li>consecutive statements in blocks are merged into a sequence; in many
    cases, this leaves blocks with a single statement, so then we can remove
    the block brackets.

</li>
<li>various optimizations for IF statements:

<ul>
<li>if (foo) bar(); else baz(); ==&gt; foo?bar():baz();
</li>
<li>if (!foo) bar(); else baz(); ==&gt; foo?baz():bar();
</li>
<li>if (foo) bar(); ==&gt; foo&amp;&amp;bar();
</li>
<li>if (!foo) bar(); ==&gt; foo||bar();
</li>
<li>if (foo) return bar(); else return baz(); ==&gt; return foo?bar():baz();
</li>
<li>if (foo) return bar(); else something(); ==&gt; {if(foo)return bar();something()}

</li>
</ul>

</li>
<li>remove some unreachable code and warn about it (code that follows a
    <code>return</code>, <code>throw</code>, <code>break</code> or <code>continue</code> statement, except
    function/variable declarations).

</li>
<li>act a limited version of a pre-processor (c.f. the pre-processor of
    C/C++) to allow you to safely replace selected global symbols with
    specified values.  When combined with the optimisations above this can
    make UglifyJS operate slightly more like a compilation process, in
    that when certain symbols are replaced by constant values, entire code
    blocks may be optimised away as unreachable.
</li>
</ul>

</li>
</ul>



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> <span class="target">Unsafe transformations</span>  </h3>
<div class="outline-text-3" id="text-1-1">


<p>
The following transformations can in theory break code, although they're
probably safe in most practical cases.  To enable them you need to pass the
<code>--unsafe</code> flag.
</p>

</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Calls involving the global Array constructor </h4>
<div class="outline-text-4" id="text-1-1-1">


<p>
The following transformations occur:
</p>



<pre class="src src-js"><span class="org-keyword">new</span> <span class="org-type">Array</span>(1, 2, 3, 4)  =&gt; [1,2,3,4]
Array(a, b, c)         =&gt; [a,b,c]
<span class="org-keyword">new</span> <span class="org-type">Array</span>(5)           =&gt; Array(5)
<span class="org-keyword">new</span> <span class="org-type">Array</span>(a)           =&gt; Array(a)
</pre>


<p>
These are all safe if the Array name isn't redefined.  JavaScript does allow
one to globally redefine Array (and pretty much everything, in fact) but I
personally don't see why would anyone do that.
</p>
<p>
UglifyJS does handle the case where Array is redefined locally, or even
globally but with a <code>function</code> or <code>var</code> declaration.  Therefore, in the
following cases UglifyJS <b>doesn't touch</b> calls or instantiations of Array:
</p>



<pre class="src src-js"><span class="org-comment-delimiter">// </span><span class="org-comment">case 1.  globally declared variable</span>
  <span class="org-keyword">var</span> <span class="org-variable-name">Array</span>;
  <span class="org-keyword">new</span> <span class="org-type">Array</span>(1, 2, 3);
  Array(a, b);

  <span class="org-comment-delimiter">// </span><span class="org-comment">or (can be declared later)</span>
  <span class="org-keyword">new</span> <span class="org-type">Array</span>(1, 2, 3);
  <span class="org-keyword">var</span> <span class="org-variable-name">Array</span>;

  <span class="org-comment-delimiter">// </span><span class="org-comment">or (can be a function)</span>
  <span class="org-keyword">new</span> <span class="org-type">Array</span>(1, 2, 3);
  <span class="org-keyword">function</span> <span class="org-function-name">Array</span>() { ... }

<span class="org-comment-delimiter">// </span><span class="org-comment">case 2.  declared in a function</span>
  (<span class="org-keyword">function</span>(){
    a = <span class="org-keyword">new</span> <span class="org-type">Array</span>(1, 2, 3);
    b = Array(5, 6);
    <span class="org-keyword">var</span> <span class="org-variable-name">Array</span>;
  })();

  <span class="org-comment-delimiter">// </span><span class="org-comment">or</span>
  (<span class="org-keyword">function</span>(<span class="org-variable-name">Array</span>){
    <span class="org-keyword">return</span> Array(5, 6, 7);
  })();

  <span class="org-comment-delimiter">// </span><span class="org-comment">or</span>
  (<span class="org-keyword">function</span>(){
    <span class="org-keyword">return</span> <span class="org-keyword">new</span> <span class="org-type">Array</span>(1, 2, 3, 4);
    <span class="org-keyword">function</span> <span class="org-function-name">Array</span>() { ... }
  })();

  <span class="org-comment-delimiter">// </span><span class="org-comment">etc.</span>
</pre>


</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> <code>obj.toString()</code> ==&gt; <code>obj+“”</code> </h4>
<div class="outline-text-4" id="text-1-1-2">


</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Install (NPM) </h3>
<div class="outline-text-3" id="text-1-2">


<p>
UglifyJS is now available through NPM &mdash; <code>npm install uglify-js</code> should do
the job.
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> Install latest code from GitHub </h3>
<div class="outline-text-3" id="text-1-3">





<pre class="src src-sh"><span class="org-comment-delimiter">## </span><span class="org-comment">clone the repository</span>
mkdir -p /where/you/wanna/put/it
<span class="org-builtin">cd</span> /where/you/wanna/put/it
git clone git://github.com/mishoo/UglifyJS.git

<span class="org-comment-delimiter">## </span><span class="org-comment">make the module available to Node</span>
mkdir -p ~/.node_libraries/
<span class="org-builtin">cd</span> ~/.node_libraries/
ln -s /where/you/wanna/put/it/UglifyJS/uglify-js.js

<span class="org-comment-delimiter">## </span><span class="org-comment">and if you want the CLI script too:</span>
mkdir -p ~/bin
<span class="org-builtin">cd</span> ~/bin
ln -s /where/you/wanna/put/it/UglifyJS/bin/uglifyjs
  <span class="org-comment-delimiter"># </span><span class="org-comment">(then add ~/bin to your $PATH if it's not there already)</span>
</pre>


</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Usage </h3>
<div class="outline-text-3" id="text-1-4">


<p>
There is a command-line tool that exposes the functionality of this library
for your shell-scripting needs:
</p>



<pre class="src src-sh">uglifyjs [ options... ] [ filename ]
</pre>


<p>
<code>filename</code> should be the last argument and should name the file from which
to read the JavaScript code.  If you don't specify it, it will read code
from STDIN.
</p>
<p>
Supported options:
</p>
<ul>
<li><code>-b</code> or <code>--beautify</code> &mdash; output indented code; when passed, additional
  options control the beautifier:

<ul>
<li><code>-i N</code> or <code>--indent N</code> &mdash; indentation level (number of spaces)

</li>
<li><code>-q</code> or <code>--quote-keys</code> &mdash; quote keys in literal objects (by default,
    only keys that cannot be identifier names will be quotes).

</li>
</ul>

</li>
<li><code>--ascii</code> &mdash; pass this argument to encode non-ASCII characters as
  <code>\uXXXX</code> sequences.  By default UglifyJS won't bother to do it and will
  output Unicode characters instead.  (the output is always encoded in UTF8,
  but if you pass this option you'll only get ASCII).

</li>
<li><code>-nm</code> or <code>--no-mangle</code> &mdash; don't mangle names.

</li>
<li><code>-nmf</code> or <code>--no-mangle-functions</code> &ndash; in case you want to mangle variable
  names, but not touch function names.

</li>
<li><code>-ns</code> or <code>--no-squeeze</code> &mdash; don't call <code>ast_squeeze()</code> (which does various
  optimizations that result in smaller, less readable code).

</li>
<li><code>-mt</code> or <code>--mangle-toplevel</code> &mdash; mangle names in the toplevel scope too
  (by default we don't do this).

</li>
<li><code>--no-seqs</code> &mdash; when <code>ast_squeeze()</code> is called (thus, unless you pass
  <code>--no-squeeze</code>) it will reduce consecutive statements in blocks into a
  sequence.  For example, "a = 10; b = 20; foo();" will be written as
  "a=10,b=20,foo();".  In various occasions, this allows us to discard the
  block brackets (since the block becomes a single statement).  This is ON
  by default because it seems safe and saves a few hundred bytes on some
  libs that I tested it on, but pass <code>--no-seqs</code> to disable it.

</li>
<li><code>--no-dead-code</code> &mdash; by default, UglifyJS will remove code that is
  obviously unreachable (code that follows a <code>return</code>, <code>throw</code>, <code>break</code> or
  <code>continue</code> statement and is not a function/variable declaration).  Pass
  this option to disable this optimization.

</li>
<li><code>-nc</code> or <code>--no-copyright</code> &mdash; by default, <code>uglifyjs</code> will keep the initial
  comment tokens in the generated code (assumed to be copyright information
  etc.).  If you pass this it will discard it.

</li>
<li><code>-o filename</code> or <code>--output filename</code> &mdash; put the result in <code>filename</code>.  If
  this isn't given, the result goes to standard output (or see next one).

</li>
<li><code>--overwrite</code> &mdash; if the code is read from a file (not from STDIN) and you
  pass <code>--overwrite</code> then the output will be written in the same file.

</li>
<li><code>--ast</code> &mdash; pass this if you want to get the Abstract Syntax Tree instead
  of JavaScript as output.  Useful for debugging or learning more about the
  internals.

</li>
<li><code>-v</code> or <code>--verbose</code> &mdash; output some notes on STDERR (for now just how long
  each operation takes).

</li>
<li><code>-d SYMBOL[=VALUE]</code> or <code>--define SYMBOL[=VALUE]</code> &mdash; will replace
  all instances of the specified symbol where used as an identifier
  (except where symbol has properly declared by a var declaration or
  use as function parameter or similar) with the specified value. This
  argument may be specified multiple times to define multiple
  symbols - if no value is specified the symbol will be replaced with
  the value <code>true</code>, or you can specify a numeric value (such as
  <code>1024</code>), a quoted string value (such as ="object"= or
  ='https://github.com'<code>), or the name of another symbol or keyword   (such as =null</code> or <code>document</code>).
  This allows you, for example, to assign meaningful names to key
  constant values but discard the symbolic names in the uglified
  version for brevity/efficiency, or when used wth care, allows
  UglifyJS to operate as a form of <b>conditional compilation</b>
  whereby defining appropriate values may, by dint of the constant
  folding and dead code removal features above, remove entire
  superfluous code blocks (e.g. completely remove instrumentation or
  trace code for production use).
  Where string values are being defined, the handling of quotes are
  likely to be subject to the specifics of your command shell
  environment, so you may need to experiment with quoting styles
  depending on your platform, or you may find the option
  <code>--define-from-module</code> more suitable for use.

</li>
<li><code>-define-from-module SOMEMODULE</code> &mdash; will load the named module (as
  per the NodeJS <code>require()</code> function) and iterate all the exported
  properties of the module defining them as symbol names to be defined
  (as if by the <code>--define</code> option) per the name of each property
  (i.e. without the module name prefix) and given the value of the
  property. This is a much easier way to handle and document groups of
  symbols to be defined rather than a large number of <code>--define</code>
  options.

</li>
<li><code>--unsafe</code> &mdash; enable other additional optimizations that are known to be
  unsafe in some contrived situations, but could still be generally useful.
  For now only these:

<ul>
<li>foo.toString()  ==&gt;  foo+""
</li>
<li>new Array(x,&hellip;)  ==&gt; [x,&hellip;]
</li>
<li>new Array(x) ==&gt; Array(x)

</li>
</ul>

</li>
<li><code>--max-line-len</code> (default 32K characters) &mdash; add a newline after around
  32K characters.  I've seen both FF and Chrome croak when all the code was
  on a single line of around 670K.  Pass &ndash;max-line-len 0 to disable this
  safety feature.

</li>
<li><code>--reserved-names</cod