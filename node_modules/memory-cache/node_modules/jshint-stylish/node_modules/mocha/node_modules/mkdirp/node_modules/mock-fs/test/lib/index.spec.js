var fs = require('fs');
var os = require('os');
var path = require('path');

var mock = require('../../lib/index');
var assert = require('../helper').assert;

describe('The API', function() {

  describe('mock()', function() {

    it('configures the real fs module with a mock file system', function() {
      mock({
        'fake-file-for-testing-only': 'file content'
      });

      assert.isTrue(fs.existsSync('fake-file-for-testing-only'));

      mock.restore();
    });

  });

  describe('mock()', function() {

    it('creates process.cwd() and os.tmpdir() by default', function() {
      mock();

      assert.isTrue(fs.statSync(process.cwd()).isDirectory());
      var tmp;
      if (os.tmpdir) {
        tmp = os.tmpdir();
      } else if (os.tmpDir) {
        tmp = os.tmpDir();
      }
      if (tmp) {
        assert.isTrue(fs.statSync(tmp).isDirectory());
      }

      mock.restore();
    });

  });

  describe('mock.restore()', function() {

    it('restores bindings for the real file system', function() {
      mock({
        'fake-file-for-testing-only': 'file content'
      });

      assert.isTrue(fs.existsSync('fake-file-for-testing-only'));

      mock.restore();
      assert.isFalse(fs.existsSync('fake-file-for-testing-only'));
    });

  });

  describe('mock.file()', function() {

    afterEach(mock.restore);

    it('lets you create files with additional properties', function(done) {

      mock({
        'path/to/file.txt': mock.file({
          content: 'file content',
          mtime: new Date(8675309),
          mode: 0644
        })
      });

      fs.stat('path/to/file.txt', function(err, stats) {
        if (err) {
          return done(err);
        }
        assert.isTrue(stats.isFile());
        assert.isFalse(stats.isDirectory());
        assert.equal(stats.mtime.getTime(), 8675309);
        assert.equal(stats.mode & 0777, 0644);
        done();
      });

    });

  });

  describe('mock.directory()', function() {

    afterEach(mock.restore);

    it('lets you create directories with more properties', function(done) {

      mock({
        'path/to/dir': mock.directory({
          mtime: new Date(8675309),
          mode: 0644
        })
      });

      fs.stat('path/to/dir', function(err, stats) {
        if (err) {
          return done(err);
        }
        assert.isFalse(stats.isFile());
        assert.isTrue(stats.isDirectory());
        assert.equal(stats.mtime.getTime(), 8675309);
        assert.equal(stats.mode & 0777, 0644);
        done();
      });

    });

    it('works with a trailing slash', function() {

      mock({
        'path/to/dir/': mock.directory({
          mtime: new Date(8675309),
          mode: 0644
        })
      });

      assert.isTrue(fs.statSync('path/to/dir').isDirectory());
      assert.isTrue(fs.statSync('path/to/dir/').isDirectory());

    });

    it('works without a trailing slash', function() {

      mock({
        'path/to/dir': mock.directory({
          mtime: new Date(8675309),
          mode: 0644
        })
      });

      assert.isTrue(fs.statSync('path/to/dir').isDirectory());
      assert.isTrue(fs.statSync('path/to/dir/').isDirectory());

    });

  });

  describe('mock.symlink()', function() {

    afterEach(mock.restore);

    it('lets you create symbolic links', function() {

      mock({
        'path/to/file': 'content',
        'path/to/link': mock.symlink({path: './file'})
      });

      var stats = fs.statSync('path/to/link');
      assert.isTrue(stats.isFile());
      assert.equal(String(fs.readFileSync('path/to/link')), 'content');

    });

  });

  describe('mock.fs()', function() {

    it('generates a mock fs module with a mock file system', function(done) {

      var mockFs = mock.fs({
        'path/to/file.txt': 'file content'
      });

      mockFs.exists('path/to/file.txt', function(exists) {
        assert.isTrue(exists);
        done();
      });

    });

    it('accepts an arbitrary nesting of files and directories', function() {

      var mockFs = mock.fs({
        'dir-one': {
          'dir-two': {
            'some-file.txt': 'file content here'
          }
        },
        'empty-dir': {}
      });

      assert.isTrue(mockFs.existsSync('dir-one/dir-two/some-file.txt'));
      assert.isTrue(mockFs.statSync('dir-one/dir-two/some-file.txt').isFile());
      assert.isTrue(mockFs.statSync('dir-one/dir-two').isDirectory());
      assert.isTrue(mockFs.statSync('empty-dir').isDirectory());

    });

  });

});

describe('Mocking the file system', function() {

  describe('fs.rename(oldPath, newPath, callback)', function() {

    beforeEach(function() {
      mock({
        'path/to/a.bin': new Buffer([1, 2, 3]),
        'empty': {},
        'nested': {
          'dir': mock.directory({
            mtime: new Date(1),
            items: {'file.txt': ''}
          })
        }
      });
    });
    afterEach(mock.restore);

    it('allows files to be renamed', function(done) {
      fs.rename('path/to/a.bin', 'path/to/b.bin', function(err) {
        assert.isTrue(!err);
        assert.isFalse(fs.existsSync('path/to/a.bin'));
        assert.isTrue(fs.existsSync('path/to/b.bin'));
        done();
      });
    });

    it('updates mtime of parent directory', function(done) {
      var oldTime = fs.statSync('nested/dir').mtime;
      fs.rename('nested/dir/file.txt', 'nested/dir/renamed.txt', function(err) {
        assert.isTrue(!err);
        assert.isFalse(fs.existsSync('nested/dir/file.txt'));
        assert.isTrue(fs.existsSync('nested/dir/renamed.txt'));
        var newTime = fs.statSync('nested/dir').mtime;
        assert.isTrue(newTime > oldTime);
        done();
      });
    });

    it('calls callback with error if old path does not exist', function(done) {
      fs.rename('bogus', 'empty', function(err) {
        assert.instanceOf(err, Error);
        done();
      });
    });

    it('overwrites existing files', function(done) {
      fs.rename('path/to/a.bin', 'nested/dir/file.txt', function(err) {
        assert.isTrue(!err);
        assert.isFalse(fs.existsSync('path/to/a.bin'));
        assert.isTrue(fs.existsSync('nested/dir/file.txt'));
        done();
      });
    });

    it('allows directories to be renamed', function(done) {
      fs.rename('path/to', 'path/foo', function(err) {
        assert.isTrue(!err);
        assert.isFalse(fs.existsSync('path/to'));
        assert.isTrue(fs.existsSync('path/foo'));
        assert.deepEqual(fs.readdirSync('path/foo'), ['a.bin']);
        done();
      });
    });

    it('calls callback with error if new directory not empty', function(done) {
      fs.rename('path', 'nested', function(err) {
        assert.instanceOf(err, Error);
        done();
      });
    });

  });

  describe('fs.renameSync(oldPath, newPath)', function() {

    beforeEach(function() {
      mock({
        'path/to/a.bin': new Buffer([1, 2, 3]),
        'empty': {},
        'nested': {
          'dir': {
            'file.txt': ''
          }
        },
        'link': mock.symlink({path: './path/to/a.bin'})
      });
    });
    afterEach(mock.restore);

    it('allows files to be renamed', function() {
      fs.renameSync('path/to/a.bin', 'path/to/b.bin');
      assert.isFalse(fs.existsSync('path/to/a.bin'));
      assert.isTrue(fs.existsSync('path/to/b.bin'));
    });

    it('overwrites existing files', function() {
      fs.renameSync('path/to/a.bin', 'nested/dir/file.txt');
      assert.isFalse(fs.existsSync('path/to/a.bin'));
      assert.isTrue(fs.existsSync('nested/dir/file.txt'));
    });

    it('allows directories to be renamed', function() {
      fs.renameSync('path/to', 'path/foo');
      assert.isFalse(fs.existsSync('path/to'));
      assert.isTrue(fs.existsSync('path/foo'));
      assert.deepEqual(fs.readdirSync('path/foo'), ['a.bin']);
    });

    it('replaces existing directories (if empty)', function() {
      fs.renameSync('path/to', 'empty');
      assert.isFalse(fs.existsSync('path/to'));
      assert.isTrue(fs.existsSync('empty'));
      assert.deepEqual(fs.readdirSync('empty'), ['a.bin']);
    });

    it('renames symbolic links', function() {
      fs.renameSync('link', 'renamed');
      assert.isTrue(fs.existsSync('renamed'));
      assert.isFalse(fs.existsSync('link'));
      assert.isTrue(fs.existsSync('path/to/a.bin'));
    });

    it('throws if old path does not exist', function() {
      assert.throws(function() {
        fs.renameSync('bogus', 'empty');
      });
    });

    it('throws if new path basename is not directory', function() {
      assert.throws(function() {
        fs.renameSync('path/to/a.bin', 'bogus/a.bin');
      });
    });

    it('throws if new dir is not empty dir', function() {
      assert.throws(function() {
        fs.renameSync('path/to', 'nested');
      });
    });

  });

  describe('fs.stat(path, callback)', function() {

    beforeEach(function() {
      mock({
        '/path/to/file.txt': mock.file({
          ctime: new Date(1),
          mtime: new Date(2),
          atime: new Date(3),
          uid: 42,
          gid: 43
        }),
        '/dir/symlink': mock.symlink({path: '/path/to/file.txt'}),
        '/empty': {}
      });
    });
    afterEach(mock.restore);

    it('creates an instance of fs.Stats', function(done) {

      fs.stat('/path/to/file.txt', function(err, stats) {
        if (err) {
          return done(err);
        }
        assert.instanceOf(stats, fs.Stats);
        done();
      });

    });

    it('identifies files', function(done) {

      fs.stat('/path/to/file.txt', function(err, stats) {
        if (err) {
          return done(err);
        }
        assert.isTrue(stats.isFile());
        assert.isFalse(stats.isDirectory());
        done();
      });

    });

    it('identifies directories', function(done) {

      fs.stat('/empty', function(err, stats) {
        if (err) {
          return done(err);
        }
        assert.isTrue(stats.isDirectory());
        assert.isFalse(stats.isFile());
        done();
      });

    });

    it('provides file stats', function(done) {
      fs.stat('/path/to/file.txt', function(err, stats) {
        if (err) {
          return done(err);
        }
        assert.equal(stats.ctime.getTime(), 1);
        assert.equal(stats.mtime.getTime(), 2);
        assert.equal(stats.atime.getTime(), 3);
        assert.equal(stats.uid, 42);
        assert.equal(stats.gid, 43);
        assert.equal(stats.nlink, 1);
        assert.isNumber(stats.blocks);
        assert.isNumber(stats.blksize);
        assert.isNumber(stats.rdev);
        done();
      });
    });

    it('provides directory stats', function(done) {
      fs.stat('/path', function(err, stats) {
        if (err) {
          return done(err);
        }
        assert.instanceOf(stats.ctime, Date);
        assert.instanceOf(stats.mtime, Date);
        assert.instanceOf(stats.atime, Date);
        if (process.getuid) {
          assert.isNumber(stats.uid);
        } else {
          assert.isUndefined(stats.uid);
        }
        if (process.getgid) {
          assert.isNumber(stats.gid);
        } else {
          assert.isUndefined(stats.gid);
        }
        assert.equal(stats.nlink, 3);
        assert.isNumber(stats.blocks);
        assert.isNumber(stats.blksize);
        assert.isNumber(stats.rdev);
        done();
      });
    });

  });

  describe('fs.fstat(fd, callback)', function() {

    beforeEach(function() {
      mock({
        'path/to/file.txt': 'file content',
        'empty': {}
      });
    });
    afterEach(mock.restore);

    it('accepts a file descriptor for a file (r)', function(done) {

      var fd = fs.openSync('path/to/file.txt', 'r');
      fs.fstat(fd, function(err, stats) {
        if (err) {
          return done(err);
        }
        assert.isTrue(stats.isFile());
        assert.equal(stats.size, 12);
        done();
      });

    });

    it('accepts a file descriptor for a directory (r)', function(done) {

      var fd = fs.openSync('path/to', 'r');
      fs.fstat(fd, function(err, stats) {
        if (err) {
          return done(err);
        }
        assert.isTrue(stats.isDirectory());
        assert.isTrue(stats.size > 0);
        done();
      });

    });

    it('fails for bad file descriptor', function(done) {

      var fd = fs.openSync('path/to/file.txt', 'r');
      fs.closeSync(fd);
      fs.fstat(fd, function(err, stats) {
        assert.instanceOf(err, Error);
        done();
      });

    });

  });

  describe('fs.fstatSync(fd)', function() {

    beforeEach(function() {
      mock({
        'path/to/file.txt': 'file content',
        'empty': {}
      });
    });
    afterEach(mock.restore);

    it('accepts a file descriptor for a file (r)', function() {

      var fd = fs.openSync('path/to/file.txt', 'r');
      var stats = fs.fstatSync(fd);
      assert.isTrue(stats.isFile());
      assert.equal(stats.size, 12);

    });

    it('accepts a file descriptor for a directory (r)', function() {

      var fd = fs.openSync('path/to', 'r');
      var stats = fs.fstatSync(fd);
      assert.isTrue(stats.isDirectory());
      assert.isTrue(stats.size > 0);

    });

    it('fails for bad file descriptor', function() {

      var fd = fs.openSync('path/to/file.txt', 'r');
      fs.closeSync(fd);
      assert.throws(function() {
        fs.fstatSync(fd);
      });

    });

  });

  describe('fs.exists(path, callback)', function() {

    beforeEach(function() {
      mock({
        'path/to/a.bin': new Buffer([1, 2, 3]),
        'empty': {},
        'nested': {
          'dir': {
            'file.txt': ''
          }
        }
      });
    });
    afterEach(mock.restore);

    it('calls with true if file exists', function(done) {
      fs.exists(path.join('path', 'to', 'a.bin'), function(exists) {
        assert.isTrue(exists);
        done();
      });
    });

    it('calls with true if directory exists', function(done) {
      fs.exists('path', function(exists) {
        assert.isTrue(exists);
        done();
      });
    });

    it('calls with true if empty directory exists', function(done) {
      fs.exists('empty', function(exists) {
        assert.isTrue(exists);
        done();
      });
    });

    it('calls with true if nested directory exists', function(done) {
      fs.exists(path.join('nested', 'dir'), function(exists) {
        assert.isTrue(exists);
        done();
      });
    });

    it('calls with true if file exists', function(done) {
      fs.exists(path.join('path', 'to', 'a.bin'), function(exists) {
        assert.isTrue(exists);
        done();
      });
    });

    it('calls with true if empty file exists', function(done) {
      fs.exists(path.join('nested', 'dir', 'file.txt'), function(exists) {
        assert.isTrue(exists);
        done();
      });
    });

    it('calls with false for bogus path', function(done) {
      fs.exists(path.join('bogus', 'path'), function(exists) {
        assert.isFalse(exists);
        done();
      });
    });

    it('calls with false for bogus path (II)', function(done) {
      fs.exists(path.join('nested', 'dir', 'none'), function(exists) {
        assert.isFalse(exists);
        done();
      });
    });

  });


  describe('fs.existsSync(path)', function() {

    beforeEach(function() {
      mock({
        'path/to/a.bin': new Buffer([1, 2, 3]),
        'empty': {},
        'nested': {
          'dir': {
            'file.txt': ''
          }
        }
      });
    });
    afterEach(mock.restore);

    it('returns true if file exists', function() {
      assert.isTrue(fs.existsSync(path.join('path', 'to', 'a.bin')));
    });

    it('returns true if directory exists', function() {
      assert.isTrue(fs.existsSync('path'));
    });

    it('returns true if empty directory exists', function() {
      assert.isTrue(fs.existsSync('empty'));
    });

    it('returns true if nested directory exists', function() {
      assert.isTrue(fs.existsSync(path.join('nested', 'dir')));
    });

    it('returns true if file exists', function() {
      assert.isTrue(fs.existsSync(path.join('path', 'to', 'a.bin')));
    });

    it('returns true if empty file exists', function() {
      assert.isTrue(fs.existsSync(path.join('nested', 'dir', 'file.txt')));
    });

    it('returns false for bogus path', function() {
      assert.isFalse(fs.existsSync(path.join('bogus', 'path')));
    });

    it('returns false for bogus path (II)', function() {
      assert.isFalse(fs.existsSync(path.join('nested', 'dir', 'none')));
    });

  });

  describe('fs.readdirSync(path)', function() {

    beforeEach(function() {
      mock({
        'path/to/file.txt': 'file content',
        'nested': {
          'sub': {
            'dir': {
              'one.txt': 'one content',
              'two.txt': 'two content',
              'empty': {}
            }
          }
        }
      });
    });
    afterEach(mock.restore);

    it('lists directory contents', function() {
      var items = fs.readdirSync(path.join('path', 'to'));
      assert.isArray(items);
      assert.deepEqual(items, ['file.txt']);
    });

    it('lists nested directory contents', function() {
      var items = fs.readdirSync(path.join('nested', 'sub', 'dir'));
      assert.isArray(items);
      assert.deepEqual(items, ['empty', 'one.txt', 'two.txt']);
    });

    it('throws for bogus path', function() {
      assert.throws(function() {
        fs.readdirSync('bogus');
      });
    });

  });


  describe('fs.readdir(path, callback)', function() {

    beforeEach(function() {
      mock({
        'path/to/file.txt': 'file content',
        'nested': {
          'sub': {
            'dir': {
              'one.txt': 'one content',
              'two.txt': 'two content',
              'empty': {}
            }
          }
        }
      });
    });
    afterEach(mock.restore);

    it('lists directory contents', function(done) {
      fs.readdir(path.join('path', 'to'), function(err, items) {
        assert.isNull(err);
        assert.isArray(items);
        assert.deepEqual(items, ['file.txt']);
        done();
      });
    });

    it('lists nested directory contents', function(done) {
      fs.readdir(path.join('nested', 'sub', 'dir'), function(err, items) {
        assert.isNull(err);
        assert.isArray(items);
        assert.deepEqual(items, ['empty', 'one.txt', 'two.txt']);
        done();
      });
    });

    it('calls with an error for bogus path', function(done) {
      fs.readdir('bogus', function(err, items) {
        assert.instanceOf(err, Error);
        assert.isUndefined(items);
        done();
      });
    });

  });

  describe('fs.readdirSync(path)', function() {

    beforeEach(function() {
      mock({
        'path/to/file.txt': 'file content',
        'nested': {
          'sub': {
            'dir': {
              'one.txt': 'one content',
              'two.txt': 'two content',
              'empty': {}
            }
          }
        }
      });
    });
    afterEach(mock.restore);

    it('lists directory contents', function() {
      var items = fs.readdirSync(path.join('path', 'to'));
      assert.isArray(items);
      assert.deepEqual(items, ['file.txt']);
    });

    it('lists nested directory contents', function() {
      var items = fs.readdirSync(path.join('nested', 'sub', 'dir'));
      assert.isArray(items);
      assert.deepEqual(items, ['empty', 'one.txt', 'two.txt']);
    });

    it('throws for bogus path', function() {
      assert.throws(function() {
        fs.readdirSync('bogus');
      });
    });

  });

  describe('fs.open(path, flags, [mode], callback)', function() {

    beforeEach(function() {
      mock({
        'path/to/file.txt': 'file content',
        'nested': {
          'sub': {
            'dir': {
              'one.txt': 'one content',
              'two.txt': 'two content',
              'empty': {}
            }
          }
        }
      });
    });
    afterEach(mock.restore);

    it('opens an existing file for reading (r)', function(done) {
      fs.open('nested/sub/dir/one.txt', 'r', function(err, fd) {
        if (err) {
          return done(err);
        }
        assert.isNumber(fd);
        done();
      });
    });

    it('fails if file does not exist (r)', function(done) {
      fs.open('bogus.txt', 'r', function(err, fd) {
        assert.instanceOf(err, Error);
        done();
      });
    });

    it('creates a new file for writing (w)', function(done) {
      fs.open('path/to/new.txt', 'w', 0666, function(err, fd) {
        if (err) {
          return done(err);
        }
        assert.isNumber(fd);
        assert.isTrue(fs.existsSync('path/to/new.txt'));
        done();
      });
    });

    it('opens an existing file for writing (w)', function(done) {
      fs.open('path/to/one.txt', 'w', 0666, function(err, fd) {
        if (err) {
          return done(err);
        }
        assert.isNumber(fd);
        done();
      });
    });

    it('fails if file exists (wx)', function(done) {
      fs.open('path/to/one.txt', 'wx', 0666, function(err, fd) {
        if (err) {
          return done(err);
        }
        assert.isNumber(fd);
        done();
      });
    });

  });

  describe('fs.openSync(path, flags, [mode])', function() {

    beforeEach(function() {
      mock({
        'path/to/file.txt': 'file content',
        'nested': {
          'sub': {
            'dir': {
              'one.tx