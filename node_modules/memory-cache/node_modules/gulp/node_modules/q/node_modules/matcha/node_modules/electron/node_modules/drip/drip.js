/*!
 * drip - Node.js event emitter.
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

!function (name, definition) {
  if (typeof module != 'undefined') module.exports = definition();
  else if (typeof define == 'function' && typeof define.amd  == 'object') define(definition);
  else this[name] = definition();
}('drip', function () {
  var module = {};

/*!
 * drip - Node.js event emitter.
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * concat (arr1, arr2(
 *
 * A much faster concat for two arrays.
 * Returns a new array.
 *
 * @param {Array} first array
 * @param {Array} second array
 * @returns {Array} combined
 * @api private
 */

function concat (arr1, arr2) {
  var l1 = arr1.length
    , l2 = arr2.length
    , res = Array(l1 + l2);
  for (var i = 0; i < l1; i++) res[i] = arr1[i];
  for (var i2 = 0; i2 < l2; i2++) res[i + i2] = arr2[i2];
  return res;
}


/*!
 * primary module export
 */

var exports = module.exports = Drip;

/*!
 * version export
 */

exports.version = '0.3.0';

/**
 * ## Drip API
 *
 * Create new instance of drip. Can also be easily
 * be used as the basis for other objects.
 *
 *     var drop = new Drip();
 *
 *
 * Namespacing is off by default. To turn it on, use
 * the `delimeter` option, indicating what delimeter will
 * be used if you choose to listen by string. The recommended
 * standard is `:` or `::`.
 *
 *     // for namespaced events
 *     var drop = new Drip({ delimeter: ':' });
 *
 * You can also use drip as the basis for your own objects.
 * To do so, simply call the drip function on construction
 * inherit it's methods. This node pattern is the recommended
 * method.
 *
 *     function MyConstructor () {
 *       Drip.call(this, { delimeter: '::' });
 *       // etc
 *     }
 *
 *     util.inherits(MyConstructor, Drip);
 *
 * @header Drip API
 */

function Drip (opts) {
  /*!
   * @param {Object} options
   * @api public
   */

  if (opts) {
    // storage
    this._drip = {};
    this._drip.delimeter = opts.delimeter || ':';
    this._drip.wildcard = opts.wildcard || (opts.delimeter ? true : false);

    // toggle functions
    if (this._drip.wildcard) {
      this.on = onWildcard;
      this.off = offWildcard;
      this.emit = emitWildcard;
      this.hasListener  = hasWildcard;
    }
  }
}

/**
 * ### .on (event, callback)
 *
 * Bind a `callback` function to all emits of `event`.
 * Wildcards `*`, will be executed for every event at
 * that level of heirarchy.
 *
 *     // for simple drips
 *     drop.on('