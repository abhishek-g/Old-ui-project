/**
 * fs-utils <https://github.com/assemble/fs-utils>
 *
 * Copyright (c) 2014 Jon Schlinkert, Brian Woodward, contributors.
 * Licensed under the MIT license.
 */

const fs = require('graceful-fs');
const os = require('os');
const path = require('path');
const async = require('async');
const glob = require('globule');
const rimraf = require('rimraf');
const YAML = require('js-yaml');
const _ = require('lodash');
const file = module.exports = {};



/**
 * Utils
 */


// Build regex based on os EOL
file.EOLre = new RegExp(os.EOL, 'g');

file.arrayify = function(val) {
  return !Array.isArray(val) ? [val] : val;
};

file.escapeRegex = function(re) {
  return re.replace(/(.)/g, '\\$1');
};

// Normalize paths to use `/`
file.pathSepRegex = /[\/\\]/g;
file.normalizeSlash = function(str) {
  return str.replace(file.pathSepRegex, '/');
};
file.slashify = file.pathSepRegex;

// Normalize line endings
file.normalizeEOL = function(str) {
  return str.replace(/\r\n|\n/g, os.EOL);
};

// Normalize to newlines
file.normalizeNL = function(str) {
  return str.replace(/\r\n|\n/g, '\n');
};

// Default encoding
file.encoding = function(options) {
  options = options || {};
  return options.encoding || 'utf8';
};

file.preserveBOM = false;
file.stripBOM = function(str) {
  // Transform EOL
  var contents = (os.EOL === '\n') ? str : str.replace(os.EOL, '\n');
  // Strip UTF BOM
  if (!file.preserveBOM && contents.charCodeAt(0) === 0xFEFF) {
    contents = contents.substring(1);
    contents = contents.replace(/^\uFEFF/, '');
  }
  return contents;
};


/**
 * CWD
 */

// Change the current working directory (CWD)
file.setCWD = function() {
  var dir = path.join.apply(path, arguments);
  process.chdir(dir);
};


/**
 * Boolean checks
 */

// True if the filepath actually exist.
file.exists = function() {
  var filepath = path.join.apply(path, arguments);
  return fs.existsSync(filepath);
};

// True if the file exists and is NOT empty.
file.isEmptyFile = function() {
  var filepath = path.join.apply(path, arguments);
  if (!file.exists(filepath)) {return false;}
  filepath = file.readFileSync(filepath);
  return (filepath.length === 0 || filepath === '') ? true : false;
};

// True if the filepath is a directory.
file.isDir = function() {
  var filepath = path.join.apply(path, arguments);
  if (!fs.existsSync(filepath)) {return false;}
  return fs.statSync(filepath).isDirectory();
};

// True if the filepath is a file.
file.isFile = function() {
  var filepath = path.join.apply(path, arguments);
  if (!fs.existsSync(filepath)) {return false;}
  return fs.statSync(filepath).isFile();
};

// True if the filepath is a symbolic link.
file.isLink = function() {
  var filepath = path.join.apply(path, arguments);
  return file.exists(filepath) && fs.lstatSync(filepath).isSymbolicLink();
};



/**
 * Stats
 */

file.getStatsSync = function (filepath) {
  try {
    return fs.statSync(filepath);
  } catch (err) {
    err.message = 'Failed to retrieve "' + filepath + '" stats: ' + err.message;
    throw err;
  }
};

file.getStats = function (filepath, callback) {
  try {
    return fs.stat(filepath, callback);
  } catch (err) {
    err.message = 'Failed to retrieve "' + filepath + '" stats: ' + err.message;
    return callback(err, null);
  }
};



/**
 * Read
 */

// Read file synchronously
file.readFileSync = function(filepath, options) {
  options = options || {};
  var buffer = fs.readFileSync(String(filepath), file.encoding(options));
  try {
    return file.stripBOM(buffer);
  } catch (err) {
    err.message = 'Failed to read "' + filepath + '": ' + err.message;
    throw err;
  }
};

// Read file
file.readFile = function (filepath, options, callback) {
  options = options || {};

  if (_.isFunction(options)) {
    callback = options;
    options = {};
  }

  async.waterfall([

    function (next) {
      fs.readFile(String(filepath), file.encoding(options), next);
    }, function (contents, next) {
      try {
        next(null, file.stripBOM(contents));
      } catch (err) {
        err.message = 'Failed to read "' + filepath + '": ' + err.message;
        next(err);
      }
    }
  ],
    callback);

};

// Read JSON file synchronously and parse content as JSON
file.readJSONSync = function(filepath) {
  var buffer = file.readFileSync(filepath);
  try {
    return JSON.parse(buffer);
  } catch (err) {
    err.message = 'Failed to parse "' + filepath + '": ' + err.message;
    throw err;
  }
};

// Read JSON file asynchronously and parse content as JSON
file.readJSON = function (filepath, callback) {
  async.waterfall([
    function (next) { fs.readFile(filepath, next); },
    function (contents, next) {
      try {
        next(null, JSON.parse(contents));
      } catch (err) {
        err.message = 'Failed to parse "' + filepath + '": ' + err.message;
        next(err);
      }
    }
  ],
  callback);
};

// Read YAML file synchronously and parse content as JSON
file.readYAMLSync = function (filepath) {
  var buffer = file.readFileSync(filepath);
  try {
    return YAML.load(buffer);
  } catch (err) {
    err.message = 'Failed to parse "' + filepath + '": ' + err.message;
    throw err;
  }
};

// Read YAML file synchronously and parse content as JSON
file.readYAML = function (filepath, callback) {
  async.waterfall([
    function (next) { file.readFile(filepath, next); },
    function (contents, next) {
      try {
        next(null, YAML.load(contents));
      } catch (err) {
        err.message = 'Failed to parse "' + filepath + '": ' + err.message;
        next(err);
      }
    }
  ],
  callback);
};

// Read optional JSON
// Ben Alman, https://gist.github.com/2876125
file.readOptionalJSON = function(filepath) {
  var buffer = {};
  try {
    buffer = file.readJSONSync(filepath);
  } catch (e) {}
  return buffer;
};

file.readOptionalYAML = function(filepath) {
  var buffer = {};
  try {
    buffer = file.readYAMLSync(filepath);
  } catch (e) {}
  return buffer;
};

// Determine the reader based on extension.
file.readDataSync = function (filepath, options) {
  var opts = _.extend({}, options);
  var ext = opts.lang || opts.parse || file.ext(filepath);
  var reader = file.readJSONSync;
  switch(ext) {
    case 'json':
      reader = file.readJSONSync;
      break;
    case 'yml':
    case 'yaml':
      reader = file.readYAMLSync;
      break;
  }
  return reader(filepath, options);
};

// Determine the reader based on extension (async).
file.readData = function (filepath, options, callback) {

  if (_.isFunction(options || {})) {
    callback = options;
    options = {};
  }

  var opts = _.extend({}, options);
  var ext = opts.parse || file.ex